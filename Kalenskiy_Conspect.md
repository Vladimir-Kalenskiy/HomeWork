# Инструкция по работе с Git.

## 1 Часть

### 1 Семинар

**Git** — система контроля версий (файлов). Что-то вроде возможности сохраняться в компьютерных играх (в Git эквивалент игрового сохранения — коммит). Важно: добавление файлов к «сохранению» двухступенчатое: сначала добавляем файл в индекс (git add), потом «сохраняем» (git commit).

Любой файл в директории существующего репозитория может находиться или не находиться под версионным контролем (отслеживаемые и неотслеживаемые).

Отслеживаемые файлы могут быть в 3-х состояниях: *неизменённые, изменённые, проиндексированные* (готовые к коммиту).

## Простейший цикл работ

1. Редактирование, добавление, удаление файлов (собственно, работа).
2. Ctrl + S - сохранение изменений в файле.
3. git add (name file) - индексация/добавление файлов в индекс (указание для git какие изменения нужно будет закоммитить).
4. git commit -m(comment) - коммит (фиксация изменений) и исчерпывающий комментарий к коммиту.

## Основные команды GIT:

* *git init* - команда, инициализирущая репозиторий в заданной деректории.
* *git add* - добавление файла к отслеживанию.
* *git version* - команда, отображающая текущую установленную версию Git.
* *git commit -m"coment"* - команда, сохраняющая изменения в файле.
* *git status* - команда, отображающая сотояние репозитория.
* *git diff* - команда, отображающая отличия текущего файла от сохраненного.
* *git log* - команда, отображающая журнал всех изменений(коммитов).
* *git log --graph* - команда, отображающая визуально ветки. 
* *git checkout "name commit"* - команда, позволяющая перейти к указанному коммиту.
* *git checkout master* - команда, позволяющая перейти к основной ветке.
* *git branch* - команда, показывающая все существующие ветки.
* *git checkout <branch_name>* - команда, позволяющая перейти в указанную ветку.
* *git branch <branch_name>* - команда, создающая новую ветку.
* *git checkout -b<branch_name>* - команда, позволяющая создать и перейти к созданной ветке.

## Добавление ссылок

Одной из сильных сторон Markdown можно смело считать то, как просто размечаются гиперссылки. Для создания ссылки укажите текст ссылки, заключив его в квадратные скобки, и сразу после — URL-адрес, заключенный в круглые [Ссылка!] (http://test.com/). Также для ссылки можно указать всплывающую подсказку (title), используя кавычки внутри круглых скобок: [Ссылка!] (http://test.com/ "Ссылка на Test.com").

**Пример:**

[Ссылка на шпаргалку по git](https://github.com/cyberspacedk/Git-commands)

## Добавление изображения в **MarkDown**

### **Три способа добавления изображения:***

1. **Вставить местное изображение**

! [Альтернативный текст] (Ссылка на изображение "необязательный заголовок")

2.  **Вставить сетевое изображение** 

![Альтернативный текст](http: //test .com/pic/test.png)

3. **Сохраните изображение в файле уценки**

![avatar](data :image/png;base64,iVBORw0......)

В этот раз вы обнаружите, что эта длинная строка вставленных символов разделяет всю статью, что сильно влияет на качество написания статьи. Если вы можете поместить большую строку base64 в конце статьи, а затем вызвать ее с идентификатором в статье, статья не будет разделена так беспорядочно.

Расширенное использование

Например:

![avatar] [base64str]

[base64str]:data :image/png;base64,iVBORw0......

 **Пример:**

![Рис.1](%D0%A0%D0%B8%D1%81.1.jpg)

## **2 Часть**

### 2 Семинар

## **Что такое ветка?**

Дадим два определения ветки: на логическом и физическом уровнях.

1. **Логический уровень**.

С точки зрения логики, ветка – это последовательность коммитов. Чтобы проще было понять, что такое ветка, рассматривайте ее как некоторую временную шкалу. Коммиты в ней – снимки интересных моментов, идущие друг за другом в хронологической последовательности.
2. **Физический уровень**

На физическом уровне, то есть с точки зрения внутренней реализации Git, ветка – это ссылка на последний коммит в этой ветке.

## Немного про указатели.

**Указатель** – это ссылка на определенный коммит или ветку. А **ссылка** – это некоторая метка, которую использует Git или сам пользователь, чтобы указать на коммит или ветку.
И как мы уже сказали, физически ветки – самые настоящие указатели. Давайте приведем примеры еще некоторых часто используемых указателей:

1. **HEAD** – так называемый курсор Git. Главное назначение HEAD - определять, в каком состоянии находится рабочая копия (напомним, что рабочая копия – это все файлы репозитория, за исключением директории .git/). На какой коммит указывает HEAD – из того коммита и загружаются файлы в рабочую директорию.
2. **ORIG_HEAD** – указатель, который появляется, когда мы вручную передвигаем HEAD на какой-нибудь НЕ последний коммит. ORIG_HEAD указывает на тот же коммит, на который указывал HEAD до передвижения назад. Нужен он, чтобы мы имели возможность вернуться на хронологически последний коммит без существенных затрат (в истории мы не будем видеть все коммиты старше нашего, а поэтому не сможем узнать хэш последнего).
3. **Пользовательские указатели**. Пользователи сами могут создавать указатели. Например, вы можете создать указатель version-1.2.1, который будет указывать на коммит, в котором хранится версия 1.2.1 вашего проекта. Это довольно удобно, поскольку вы можете переключаться на коммит с той или иной версией, не запоминая его хэш.

## **Зачем же нужны ветки?**

Пока мы разбирались, что такое ветка, у вас мог возникнуть вопрос: зачем нужны такие сложности, ведь можно просто делать коммиты и откатывать изменения, когда нужно.

Дело в том, что Git – универсальная система контроля версий: она подходит и большим командам крупных корпораций, и индивидуальным разработчикам для их личных проектов.

Итак, чаще всего ветки используются в следующих случаях.

1. Ветки нужны, чтобы несколько программистов могли **вести работу** над одним и тем же проектом или даже файлом **одновременно**, при этом не мешая друг другу.
2. Кроме того, ветки используются **для тестирования экспериментальных функций**: чтобы не повредить основному проекту, создается новая ветка специально для экспериментов. Если эксперимент удался, изменения с экспериментальной ветки переносятся на основную, если нет – новая ветка попросту удаляется, а проект остается нетронутым.
3. Помимо прочего, ветки можно использовать **для** разных выходящих **параллельно релизов** одного проекта. Например, в репозитории Python может быть две ветки: python-2 и python-3. До закрытия python-2 релизы этих версий языка выходили независимо друг от друга, поэтому могло иметь место такое разделение на ветки.

На самом деле, у веток есть еще множество применений – все зависит от конкретного проекта, – мы же перечислили только самые распространенные практики их использования. Ветвление в Git – это действительно мощный инструмент, поэтому важно уметь им пользоваться.

### **Создание веток**

Выше мы уже упоминали, что как только вы создаете свой первый коммит, Git создаёт основную ветку, в нашем случае ее имя будет **master**. Тем не менее, мы можем создавать свои ветки и переключаться между ними. Создать свою ветку можно двумя способами.

1. **Команды git branch + git checkout**

Этот способ является классическим. В нем для начала работы с новой веткой нужно выполнить **два действия**:
- Создать ветку с помощью команды git branch <branch_name>
- Переключиться на свежесозданную ветку с помощью команды git checkout <branch_name>

2. **Команда git checkout -b**

В основе данного способа лежит тот факт, что команда **git checkout** умеет создавать ветки и сразу переключаться на них. Это намного удобнее, чем выполнять два этих действия по отдельности. Поэтому данный способ является более предпочтительным, так как задействует только одну команду **git checkout** со специальным ключом **-b** .

- **git checkout -b <branch_name>** - создает новую ветку и переключается на неё.

## **Просмотр списка веток**

Когда вы работаете с большим количеством веток, можно легко забыть имя нужной, а без имени ветки переключится на нее не получится. Для таких ситуаций существует команда просмотра списка веток. На самом деле, это уже знакомая нам **git branch**, но с другими ключами.

**git branch** - команда, отображающая все существующие ветки.

**git branch -r** -(-r, англ. remote - удаленный) команда, отображающая только удаленные ветки.

**git branch -a** - (-a, англ. all - все) команда, отображающая локольные и удаленные ветки.

### **Слияние веток**

**Что такое слияние и зачем оно нужно**

То есть общий ход нашей работы выглядит следующим образом:
1. Решили добавить новую функцию – создали отдельную ветку. Дальше работаем в новой ветке.
2. Написали функцию, протестировали ее работу, внесли все необходимые исправления, еще раз протестировали и убедились, что функция работает исправно и не привнесла ошибок в остальной код.
3. Теперь нужно как-то перенести изменения с тестовой ветки на основную – в продакшн. Тут нам на помощь и приходит слияние: мы просто сливаем (т.е. переносим) изменения с нашей тестовой ветки в основную.

**Сливаемая ветка** – та ветка, с которой мы берем изменения, чтобы влить их в целевую.

**Целевая ветка** – та ветка, в которую мы сливаем наши изменения.

**Слияние веток** – это перенос изменений с одной ветки на другую. При этом слияние не затрагивает сливаемую ветку, то есть она остается в том же состоянии, что позволяет нам потом продолжить работу с ней.

* *git merge <branch_name>* - (merge - англ. слияние) команда, осуществляющая слияние текущей ветки с указаной веткой (branch_name).

__*NB*__ Перед слиянине веток необходимо убедится в том, что базовая и применяемая ветка указанна верно.

### **Конфликты**
### **Неявное слияние (fast forward)**.

Во время неявного слияния не создается новых коммитов: используются только уже существующие. Суть этого слияния заключается в том, что из вливаемой ветки извлекаются несколько коммитов, а затем они применяются к последнему коммиту целевой ветки. Такое слияние называется **fast-forward**.

### **Продвинутое слияние (ort)**

Обычно выполнять слияния в Git довольно легко. Git упрощает повторные слияния с одной и той же веткой, таким образом, позволяя вам иметь очень долго живущую ветку, и вы можете сохранять ее всё это время в актуальном состоянии, часто разрешая маленькие конфликты, а не доводить дело до одного большого конфликта по завершению всех изменений.

## **Conflict**

Обычно конфликты возникают, когда два человека **изменяют одни и те же строки в файле или один разработчик удаляет файл**, который в это время изменяет другой разработчик. В таких случаях Git не может автоматически определить, какое изменение является правильным. Конфликты затрагивают только того разработчика, который выполняет слияние, остальная часть команды о конфликте не знает. Git помечает файл как конфликтующий и останавливает процесс слияния. В этом случае ответственность за разрешение конфликта несут разработчики.
